# Больше, чем RSA: Write-up

Как и в обычных задачах на RSA, нам даны три числа — *n* (модуль RSA), *e* (публичная экспонента) и *ciphertext* (зашифрованный текст). Для расшифровки текста не хватает приватной экспоненты — числа *d*.

Поскольку больше мы не имеем никаких данных, можно предположить, что проблема в выбранных параметрах алгоритма, и они позволят нам вычислить *d* и расшифровать текст.

Как и сказано в условии, полученный шифр в 1,5 раза сложнее RSA-512 — длина модуля равна 768 битам.

> Возможно, вы заметили, что каждая команда получала собственную версию таска со своими параметрами — особенности [скрипта генерации](generate.py) приводили к тому, что длина модуля могла быть на несколько бит длиннее. Это не влияло на решение таска.

С одной стороны, длина модуля в 768 бит не считается безопасной, но с другой стороны, для его наивной факторизации всё ещё необходимо достаточно много процессорного времени. Тем не менее, всё равно попробуем поискать наш модуль в базе [factordb](http://factordb.com/).

![Факторизация числа](pictures/factordb.png)

Мы видим, что у нашего числа есть делитель 64747. Однако, второй делитель не является простым числом — делитель составной, и сомножители неизвестны. Что ж, попробуем разложить и его. Воспользуемся утилитой [RsaCtfTool](https://github.com/Ganapati/RsaCtfTool). Передадим ей в качестве *n* то число, которое нам осталось разложить (исходное *n*, делённое на 64747), в качестве *e* — 65537, и попросим сохранить приватный ключ в файл.

```
$ ./RsaCtfTool.py -n 9872588838638030950696126459014442947496798784513554166987892884412794042307122053447217031027951744826371324462149828041624968085355394244292306949565356383740556153440105667681951467470397974808910155423234753531439580775823 -e 65537 --private --output private.key

<...>

[*] Performing primefac attack on /tmp/tmpkpg5zo5h.

Results for /tmp/tmpkpg5zo5h:

Private key :
-----BEGIN RSA PRIVATE KEY-----
<...>
```

Итак, приватный ключ найден, следовательно, скорее всего, число удалось факторизовать. Попробуем посмотреть его параметры:

```
$ ./RsaCtfTool.py --key private.key --dumpkey
n: 9872588838638030950696126459014442947496798784513554166987892884412794042307122053447217031027951744826371324462149828041624968085355394244292306949565356383740556153440105667681951467470397974808910155423234753531439580775823
e: 65537
d: 4505384545920414875160897662941604889966496147935233196915847542411429333312806603514035841799044521175322544089720824654121791678423351872270790118575985235128219432230876618898030986659118678216003921473457481869413400691553
p: 99360901961677214591044526636410730347838945605096236909384100179074958479771329014688978313363013565949439598093
q: 99360901961677214591044526636410730347838945605096236909384100179074958479771329014688978313363013561994553337611
```

Итак, два оставшихся делителя найдены. factordb подтверждает, что они вероятно простые. Получили три делителя *n*. Можно найти [множество](https://www.reddit.com/r/crypto/comments/2gj7c0/rsa_why_is_the_public_key_a_factor_of_2_prime/) [различных](https://crypto.stackexchange.com/questions/44110/rsa-with-3-primes) [источников](https://crypto.stackexchange.com/questions/15823/multiple-prime-rsa-how-many-primes-can-i-use-for-a-2048-bit-modulus), где обсуждаются реализации RSA, в которых используются несколько простых делителей. В целом, практически ничего не меняется.

Число *φ* — функция Эйлера для модуля — вычисляется как (*p* – 1) × (*q* – 1) × (*r* – 1). После этого мы уже можем получить *d* как обратное к *e* по модулю *φ*. Остаётся возвести *ciphertext* в степень *d* по модулю *n* и получить флаг.

[Код для решения задания](decrypt.py)

Флаг: **ugra_3rsa_is_secure_unless_you_get_bad_primes_cd68113d87efcde6**
