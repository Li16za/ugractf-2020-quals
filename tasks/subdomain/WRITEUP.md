# Запросы: Write-up

Нам даётся PCAP-файл — дамп сетевого трафика. В трафике мы видим обилие DNS-запросов очень странного вида — клиент запрашивает записи типа `NULL` на странные поддомены `subdomain.q.2020.ugractf.ru`. Кажется, что у этого домена нет DNS-сервера, но если сделать запрос к DNS-серверу домена `ugractf.ru`, то увидим интересную запись:

```
$ dig IN NS ugractf.ru

ugractf.ru.             75417   IN      NS      roan.ns.cloudflare.com.
ugractf.ru.             75417   IN      NS      liberty.ns.cloudflare.com.

$ dig subdomain.q.2020.ugractf.ru @roan.ns.cloudflare.com

subdomain.q.2020.ugractf.ru. 300 IN     NS      subns.q.2020.ugractf.ru.

;; ADDITIONAL SECTION:
subns.q.2020.ugractf.ru. 300    IN      A       10.13.37.42
```

Авторитетный DNS-сервер данного домена находится в локальной сети. И по всей видимости, из той самой сети был снят дамп трафика.

Судя по характеру данных, с реальным использованием DNS этот трафик не имеет ничего общего — вряд ли клиент правда хочет узнать что-то о доменах из нечитаемых символов. Скорее всего, в этом трафике спрятаны какие-то ещё данные. Инкапсуляция одного протокола в другой называется туннелем — мы можем поискать в интернете известные *DNS-туннели* в надежде найти готовые решения. Существует сразу несколько таких решений, чаще всего используемых для обхода так называемых «белых списков» и порталов авторизации. Одно из них — [iodine](https://code.kryo.se/iodine). По используемым кодировкам и типам записей можно понять, что из всех предлагаемых туннелей это именно он.

В описании туннеля несколько раз упоминается, что проходящий по нему трафик никак не шифруется и может быть подвергнут изменению, что означает, что нам без труда удастся извлечь данные. Но есть и препятствие — протокол довольно запутанный, и, возможно, данные удастся извлечь не сразу.

Мы написали [скрипт](get_underlying_pcap.py) для получения дампа трафика внутри туннеля в формате PCAP. Основная проблема состоит в том, что автор iodine любит неклассически кодировать данные — встречается и base16, и base32, и даже base128, причем варианты двух последних придуманы самим автором, и реализацию декодирования приходится вручную портировать с профессионального языка программирования Си из официального репозитория. Нам понадобятся некоторые заголовки (в первую очередь — маркер последнего пакета), чтобы узнать их формат, обратимся к [спецификации](https://github.com/yarrick/iodine/blob/master/doc/proto_00000502.txt), которая есть в репозитории.

Таск был сильно упрощён, поэтому были выбраны кодировки по умолчанию, пакеты не переставлялись местами, и можно было спокойно убирать все пакеты, кроме непосредственно пакетов с данными.

Запуская получившийся скрипт, получаем новый дамп трафика. Внутри — много ICMP-запросов (`ping`) и одна TCP-сессия. Эта TCP-сессия открывается на порт 80, и кажется, что это должен быть HTTP-запрос, но ничего не понятно: в дампе что-то бинарное. На самом деле, это и правда HTTP-запрос, но второй версии протокола — в нём заголовки передаются в бинарном формате. В заголовках находим первую часть флага, а в самих данных — две остальных.

Можно было попробовать просто просканировать дамп с помощью утилиты `binwalk`, в этом случае мы успешно извлекали zlib-фрагмент с содержимым страницы (поскольку данные кодируются в base128 только в upstream-направлении). Однако, насколько нам известно, участники не смогли извлечь заголовки HTTP2-ответа и решить таск полностью.

Флаг: **ugra_http2_is_nice_but_better_with_iodine_15af90c465128359**
