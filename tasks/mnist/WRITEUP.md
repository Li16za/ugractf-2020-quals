# Мнистерство статистики: Write-up

Открываем файл, видим полотнище из 267×190 цифр. Каждая располагается в квадрате 28×28 пикселей. Все они немного отличаются друг от друга, двух одинаковых нет.

Задача распознавания цифр — причём именно такого размера, 28×28 — широко используется как тренировочная задача машинного обучения. Словом MNIST называют набор данных, в котором собраны 70 000 изображений цифр; некоторые методы дают на этом наборе точность распознавания свыше 99%. Есть большое количество статей с примерами и кодом, позволяющим обучить нейронную сеть самостоятельно, а также готовые модели.

Для начала разберёмся, что значат все эти цифры. Можно обратить внимание на первый столбец: в нём есть только цифры 0, 1 и 2. Таким же свойством обладают четвёртый, седьмой и так далее столбцы. То есть если читать цифры по строкам тройками, первая из тройки будет всегда 0, 1 или 2. Посмотрев глазами, убеждаемся, что вроде бы нигде такие трёхзначные числа не превышают 255 — то есть можно интерпретировать их как десятичную запись байт. Из этих байт и сложится файл, героически записанный тётенькой из Мнистерства статистики.

Поймём, что это за файл. Первые два байта — 066 077 — это буквы `BM`. Согласно [списку сигнатур файлов в Википедии](https://en.wikipedia.org/wiki/List_of_file_signatures), такая сигнатура однозначно указывает на файл BMP — один из самых простых форматов изображений. В этих файлах зачастую отсутствует сжатие, и пиксели изображения записываются как есть. Это значит, что если изменить какой-нибудь байт в файле, то мы просто испортим один пиксель (если совсем точно, то один канал одного пикселя), а всё остальное отобразится нормально. Таким образом, добиваться идеального качества распознавания цифр необязательно: возможные ошибки не помешают воспринять картинку в целом. Главное — отсутствие ошибок в заголовке, потому что иначе файл не сможет отобразиться вовсе. Этого мы добьёмся, перепечатав первые байты вручную.

Найдём [готовый код из официальной документации keras](https://keras.io/examples/mnist_cnn/), который сделает всё за нас: скачает базу MNIST, подготовит её, создаст несложную нейронную сеть подходящей архитектуры и обучит её. Допишем только сохранение обученной модели в файл:

```python
model.save("keras-mnist.h5")
```

Поставим все необходимые библиотеки, запустим скрипт и подождём, пока он выполнится.

Теперь поработаем с нашими данными. Загрузим картинку и нарежем её на отдельные цифры по порядку.

```python
import PIL.Image
import numpy as np

img = np.asarray(PIL.Image.open("mnistry-data.png"))
img = img[:, :, 0]  # red channel only

digits = []
for y0 in range(0, img.shape[0], 28):
    for x0 in range(0, img.shape[1], 28):
        digits.append(img[y0:y0+28, x0:x0+28])
```

Распознаем цифры свежеобученной моделью. Чтобы отправить изображение цифры на распознавание, нужно превратить её — двухмерный массив 28×28 — в четырёхмерный массив 1×28×28×1. Модель вернёт 10 чисел: оценку вероятности, что цифра на картинке — 0, оценку вероятности, что цифра на картинке — 1, и так далее. Будем считать ответом ту цифру, чья оценка вероятности наибольшая — с помощью функции argmax мы выясняем номер максимального элемента в массиве, он как раз совпадает с самой цифрой.

> Четырёхмерный массив на самом деле позволяет быстро распознавать много цифр за раз. Но у нас их немного, и мы не торопимся, поэтому мы поступаем самым простым способом.

```python
from keras.models import load_model

model = load_model("keras-mnist.h5")

digits_detected = [np.argmax(model.predict(d.reshape((1, 28, 28, 1)))[0]) for d in digits]
```

Теперь склеим цифры в байты. Разбив цифры на тройки, попытаемся улучшить качество, применяя наше знание о том, что первая цифра — всегда 0, 1 или 2, а если она 2, то две последние образуют число не больше 55. По крайней мере, этим способом мы получим заведомо корректные байты.

```python
bytes_detected = [digits_detected[i:i+3] for i in range(0, len(digits_detected), 3)]
for bd in bytes_detected:
    if bd[0] > 2:
        bd[0] = 2
    if bd[0] == 2:
        bd[1] = min(bd[1], 5)
    if (bd[0], bd[1]) == (2, 5)
        bd[2] = min(bd[2], 5)

data = [(bd[0] * 100 + bd[1] * 10 + bd[2]) for bd in bytes_detected]
```

> Доступ к генератору и, соответственно, исходным данным позволяет нам рассчитать точность нашего подхода. Верно распознаны 91.48% цифр, если же рассматривать верно распознанные байты целиком, то их доля — лишь 76.79%. Впрочем, среди ошибочно распознанных байтов правильный и распознанный отличаются значениями в среднем всего на 20.58 из возможных 255 — для цвета это не очень существенное различие.

Осталось переписать первые байты вручную. Выясним, сколько точно байт нужно переписывать. Обратимся к [статье про BMP в Википедии](https://en.wikipedia.org/wiki/BMP_file_format#File_structure). В начале файла обязательно идёт 14-байтный заголовок, а дальше — число, указывающее, какого размера будет следующий заголовок. Больше обязательных заголовков в файле нет. Обнаружим, что размер второго заголовка — 40 байт, значит, нам надо переписать вручную 54 байта, или 54 × 3 = 162 цифры.

```python
first_bytes = [66, 77, 14, 66, 0, 0, 0, 0, 0, 0, 54, 0, 0, 0, 40,
               0, 0, 0, 145, 1, 0, 0, 14, 0, 0, 0, 1, 0, 24, 0, 0,
               0, 0, 0, 216, 65, 0, 0, 196, 14, 0, 0, 196, 14, 0,
               0, 0, 0, 0, 0, 0, 0, 0, 0]
data = first_bytes + data[54:]
```

Сохраним наши байты в файл.

```python
open("res.bmp", "wb").write(bytes(data))
```

Теперь можно попробовать его посмотреть.

![Файл, как его получилось распознать](writeup/res.png)

Вот он, величайший секрет всемогущего Мнистерства статистики. Несмотря на то, что каждый четвёртый байт содержит ошибку, флаг прекрасно читается. Кстати, при безошибочном распознавании картинка выглядела бы так — без ряби:

![Файл при безошибочном распознавании](writeup/res-reference.png)

Флаг: **ugra_apply_now_for_senior_ai_researcher_3493f0ce89**
